import { DocumentSnapshot } from 'firebase-admin/firestore';
import { firestore, Change, logger } from 'firebase-functions';

/**
 * writes fields common to root-level collection records that are generated by the
 * admin SDK (backend):
 * - createdAt (timestamp)
 * - updatedAt (timestamp)
 */
export const createTimestampFields = firestore
  .document('{colId}/{docId}')
  .onWrite(async (change, context) => {
    // the collections to NOT trigger
    const excludeCollections: string[] = [];

    // run the field creator if the document being touched belongs to a registered collection
    if (excludeCollections.includes(context.params.colId)) {
      return null;
    }

    // cause the creation of timestamp fields
    return _createCommonFields(change);
  });

/**
 * createTimestampFields' equivalent for sub-collection records
 */
export const createTimestampFieldsSubColl = firestore
  .document('{colId}/{colDocId}/{subColId}/{subColDocId}')
  .onWrite(async (change, context) => {
    console.log(`collection: ${context.params.colId}, subcollection: ${context.params.subColId}`);

    // the subcollections of the collections to trigger
    // triggers for documents like 'posts/postId/versions/versionId, etc
    const collections = {
      // example: 'posts': ['versions', 'tags', 'links'], 
    };

    // parse the collection and subcollection names of this document
    const colId = context.params.colId;
    const subColId = context.params.subColId;
    // check that the document being triggered belongs to a registered subcollection
    // e.g posts/versions; skip the field creation if it's not included
    if (!collections[colId]?.includes(subColId)) {
      return null;
    }

    // cause the creation of timestamp fields
    return _createCommonFields(change);
  });

/**
 * performs actual creation of timestamp fields for the
 * registered collection being written
 * @param {QueryDocumentSnapshot} change a snapshot for the collection being written
 */
async function _createCommonFields(change: Change<DocumentSnapshot>) {
  // simplify event types
  const createDoc = change.after.exists && !change.before.exists;
  const updateDoc = change.before.exists && change.after.exists;
  const deleteDoc = change.before.exists && !change.after.exists;

  if (deleteDoc) {
    return null;
  }

  // simplify input data
  const after = change.after.exists ? change.after.data() : null;
  const before = change.before.exists ? change.before.data() : null;

  // add createdAt
  if (createDoc) {
    return change.after.ref.set({
      createdAt: change.after.createTime,
      updatedAt: change.after.updateTime,
    }, { merge: true }).catch((e) => {
      logger.error(e);
      return false;
    });
  }

  // prevent update loops from triggers
  const canUpdate = () => {
    if (after?.updatedAt?._seconds !== before?.updatedAt?._seconds) {
      return false;
    }
    
    // if create trigger
    if (!before?.createdAt && after?.createdAt) {
      return false;
    }
    
    return true;
  };

  // add updatedAt
  if (updateDoc && canUpdate()) {
    return change.after.ref.set({
      updatedAt: change.after.updateTime,
    }, { merge: true }).catch((e) => {
      logger.error(e);
      return false;
    });
  }

  return null;
}
